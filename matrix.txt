ings, and in fact it is nice if your design works out that way. But you’ll 
find that there are times when it’s equally clear that you must add new methods to the 
interface of a derived class. With inspection both cases should be reasonably obvious. 
Interchangeable objects with polymorphism. 
When dealing with type hierarchies, you often want to treat an object not as the specific type 
that it is, but instead as its base type. This allows you to write code that doesn’t depend on 
specific types. In the shape example, methods manipulate generic shapes, unconcerned about 
whether they’re circles, squares, triangles, or some shape that hasn’t even been defined yet. 
All shapes can be drawn, erased, and moved, so these methods simply send a message to a 
shape object; they don’t worry about how the object copes with the message. 
Such code is unaffected by the addition of new types, and adding new types is the most 
common way to extend an object-oriented program to handle new situations. For example, 
you can derive a new subtype of shape called pentagon without modifying the methods that 
deal only with generic shapes. This ability to easily extend a design by deriving new subtypes 
is one of the essential ways to encapsulate change. This greatly improves designs while 
reducing the cost of software maintenance. 
There’s a problem, however, with attempting to treat derived-type objects as their generic 
base types (circles as shapes, bicycles as vehicles, cormorants as birds, etc.). If a method is 
going to tell a generic shape to draw itself, or a generic vehicle to steer, or a generic bird to 
move, the compiler cannot know at compile time precisely what piece of code will be 
executed. That’s the whole point—when the message is sent, the programmer doesn’t want to 
know what piece of code will be executed; the draw method can be applied equally to a circle, 
a square, or a triangle, and the object will execute the proper code depending on its specific 
type. 
If you don’t have to know what piece of code will be executed, then when you add a new 
subtype, the code it executes can be different without requiring changes to the method that 
Introduction to Objects 25
calls it. Therefore, the compiler cannot know precisely what piece of code is executed, so what 
does it do? 
For example, in the following diagram the BirdController object just works with generic 
Bird objects and does not know what exact type they are. This is convenient from 
BirdController’s perspective because it doesn’t have to write special code to determine the 
exact type of Bird it’s working with or that Bird’s behavior. So how does it happen that, 
when move( ) is called while ignoring the specific type of Bird, the right behavior will occur 
(a Goose walks, flies, or swims, and a Penguin walks or swims)? 
The answer is the primary twist in object-oriented programming: The compiler cannot make 
a function call in the traditional sense. The function call generated by a non-OOP compiler 
causes what is called early binding, a term you may not have heard before because you’ve 
never thought about it any other way. It means the compiler generates a call to a specific 
function name, and the runtime system resolves this call to the absolute address of the code 
to be executed. In OOP, the program cannot determine the address of the code until run 
time, so some other scheme is necessary when a message is sent to a generic object. 
To solve the problem, object-oriented languages use the concept of late binding. When you 
send a message to an object, the code being called isn’t determined until run time. The 
compiler does ensure that the method exists and performs type checking on the arguments 
and return value, but it doesn’t know the exact code to execute. 
To perform late binding, Java uses a special bit of code in lieu of the absolute call. This code 
calculates the address of the method body, using information stored in the object (this 
process is covered in great detail in the Polymorphism chapter). Thus, each object can 
behave differently according to the contents of that special bit of code. When you send a 
message to an object, the object actually does figure out what to do with that message. 
In some languages you must explicitly state that you want a method to have the flexibility of 
latebinding properties (C++ uses the virtual keyword to do this). In these languages, by 
default, methods are not dynamically bound. In Java, dynamic binding is the default 
behavior and you don’t need to remember to add any extra keywords in order to get 
polymorphism. 
Consider the shape example. The family of classes (all based on the same uniform interface) 
was diagrammed earlier in this chapter. To demonstrate polymorphism, we want to write a 
single piece of code that ignores the specific details of type and talks only to the base class. 
That code is decoupled from type-specific information and thus is simpler to write and easier 
to understand. And, if a new type—a Hexagon, for example—is added through inheritance, 
the code you write will work just as well for the new type of Shape as it did on the existing 
types. Thus, the program is extensible. 
26 Thinking in Java Bruce Eckel
If you write a method in Java (as you will soon learn how to do): 
void doSomething(Shape shape) { 
 shape.erase(); 
 // ... 
 shape.draw(); 
}
This method speaks to any Shape, so it is independent of the specific type of object that it’s 
drawing and erasing. If some other part of the program uses the doSomething( ) method: 
Circle circle = new Circle(); 
Triangle triangle = new Triangle(); 
Line line= new Line(); 
doSomething(circle); 
doSomething(triangle); 
doSomething(line); 
The calls to doSomething( ) automatically work correctly, regardless of the exact type of 
the object. 
This is a rather amazing trick. Consider the line: 
doSomething(circle); 
What’s happening here is that a Circle is being passed into a method that’s expecting a 
Shape. Since a Circle is a Shape it can be treated as one by doSomething( ). That is, any 
message that doSomething( ) can send to a Shape, a Circle can accept. So it is a 
completely safe and logical thing to do. 
We call this process of treating a derived type as though it were its base type upcasting. The 
name cast is used in the sense of casting into a mold and the up comes from the way the 
inheritance diagram is typically arranged, with the base type at the top and the derived 
classes fanning out downward. Thus, casting to a base type is moving up the inheritance 
diagram: “upcasting.” 
An object-oriented program contains some upcasting somewhere, because that’s how you 
decouple yourself from knowing about the exact type you’re working with. Look at the code 
in doSomething( ): 
shape.erase(); 
// ... 
shape.draw(); 
Introduction to Objects 27
Notice that it doesn’t say, “If you’re a Circle, do this, if you’re a Square, do that, etc.” If you 
write that kind of code, which checks for all the possible types that a Shape can actually be, 
it’s messy and you need to change it every time you add a new kind of Shape. Here, you just 
say, “You’re a shape, I know you can erase( ) and draw( ) yourself, do it, and take care of 
the details correctly.” 
What’s impressive about the code in doSomething( ) is that, somehow, the right thing 
happens. Calling draw( ) for Circle causes different code to be executed than when calling 
draw( ) for a Square or a Line, but when the draw( ) message is sent to an anonymous 
Shape, the correct behavior occurs based on the actual type of the Shape. This is amazing 
because, as mentioned earlier, when the Java compiler is compiling the code for 
doSomething( ), it cannot know exactly what types it is dealing with. So ordinarily, you’d 
expect it to end up calling the version of erase( ) and draw( ) for the base class Shape, and 
not for the specific Circle, Square, or Line. And yet the right thing happens because of 
polymorphism. The compiler and runtime system handle the details; all you need to know 
right now is that it does happen, and more importantly, how to design with it. When you 
send a message to an object, the object will do the right thing, even when upcasting is 
involved. 
The singly rooted hierarchy 
One of the issues in OOP that has become especially prominent since the introduction of C++ 
is whether all classes should ultimately be inherited from a single base class. In Java (as with 
virtually all other OOP languages except for C++) the answer is yes, and the name of this 
ultimate base class is simply Object. It turns out that the benefits of the singly rooted 
hierarchy are many. 
All objects in a singly rooted hierarchy have an interface in common, so they are all 
ultimately the same fundamental type. The alternative (provided by C++) is that you don’t 
know that everything is the same basic type. From a backward-compatibility standpoint this 
fits the model of C better and can be thought of as less restrictive, but when you want to do 
full-on objectoriented programming you must then build your own hierarchy to provide the 
same convenience that’s built into other OOP languages. And in any new class library you 
acquire, some other incompatible interface will be used. It requires effort (and possibly 
multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of 
C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re 
starting from scratch, other alternatives such as Java can often be more productive. 
All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You 
know you can perform certain basic operations on every object in your system. All objects can 
easily be created on the heap, and argument passing is greatly simplified. 
A singly rooted hierarchy makes it much easier to implement a garbage collector, which is 
one of the fundamental improvements of Java over C++. And since information about the 
type of an object is guaranteed to be in all objects, you’ll never end up with an object whose 
type you cannot determine. This is especially important with system-level operations, such as 
exception handling, and to allow greater flexibility in programming. 
Containers 
In general, you don’t know how many objects you’re going to need to solve a particular 
problem, or how long they will last. You also don’t know how to store those objects. How can 
you know how much space to create if that information isn’t known until run time? 
28 Thinking in Java Bruce Eckel
Introduction to Objects 29
The solution to most problems in object-oriented design seems flippant: You create another 
type of object. The new type of object that solves this particular problem holds references to 
other objects. Of course, you can do the same thing with an array, which is available in most 
languages. But this new object, generally called a container (also called a collection, but the 
Java library uses that term in a different sense so this book will use “container”), will expand 
itself whenever necessary to accommodate everything you place inside it. So you don’t need 
to know how many objects you’re going to hold in a container. Just create a container object 
and let it take care of the details. 
Fortunately, a good OOP language comes with a set of containers as part of the package. In 
C++, it’s part of the Standard C++ Library and is often called the Standard Template Library
(STL). Smalltalk has a very complete set of containers. Java also has numerous containers in 
its standard library. In some libraries, one or two generic containers is considered good 
enough for all needs, and in others (Java, for example) the library has different types of 
containers for different needs: several different kinds of List classes (to hold sequences), 
Maps (also known as associative arrays, to associate objects with other objects), Sets (to 
hold one of each type of object), and more components such as queues, trees, stacks, etc. 
From a design standpoint, all you really want is a container that can be manipulated to solve 
your problem. If a single type of container satisfied all of your needs, there’d be no reason to 
have different kinds. There are two reasons that you need a choice of containers. First, 
containers provide different types of interfaces and external behavior. A stack has a different 
interface and behavior than a queue, which is different from a set or a list. One of these might 
provide a more flexible solution to your problem than the other. Second, different containers 
have different efficiencies for certain operations. For example, there are two basic types of 
List: ArrayList and LinkedList. Both are simple sequences that can have identical 
interfaces and external behaviors. But certain operations can have significantly different 
costs. Randomly accessing elements in an ArrayList is a constant-time operation; it takes 
the same amount of time regardless of the element you select. However, in a LinkedList it is 
expensive to move through the list to randomly select an element, and it takes longer to find 
an element that is farther down the list. On the other hand, if you want to insert an element 
in the middle of a sequence, it’s cheaper in a LinkedList than in an ArrayList. These and 
other operations have different efficiencies depending on the underlying structure of the 
sequence. You might start building your program with a LinkedList and, when tuning for 
performance, change to an ArrayList. Because of the abstraction via the interface List, you 
can change from one to the other with minimal impact on your code. 
Parameterized types (generics) 
Before Java SE5, containers held the one universal type in Java: Object. The singly rooted 
hierarchy means that everything is an Object, so a container that holds Objects can hold 
anything.6 This made containers easy to reuse. 
To use such a container, you simply add object references to it and later ask for them back. 
But, since the container held only Objects, when you added an object reference into the 
container it was upcast to Object, thus losing its character. When fetching it back, you got an 
Object reference, and not a reference to the type that you put in. So how do you turn it back 
into something that has the specific type of the object that you put into the container? 
Here, the cast is used again, but this time you’re not casting up the inheritance hierarchy to a 
more general type. Instead, you cast down the hierarchy to a more specific type. This manner 
of casting is called downcasting. With upcasting, you know, for example, that a Circle is a 
type of Shape so it’s safe to upcast, but you don’t know that an Object is necessarily a 
                                                           
6 They do not hold primitives, but Java SE5 autoboxing makes this restriction almost a non-issue. This is discussed in 
detail later in the book.
Circle or a Shape so it’s hardly safe to downcast unless you know exactly what you’re 
dealing with. 
It’s not completely dangerous, however, because if you downcast to the wrong thing you’ll get 
a runtime error called an exception, which will be described shortly. When you fetch object 
references from a container, though, you must have some way to remember exactly what they 
are so you can perform a proper downcast. 
Downcasting and the runtime checks require extra time for the running program and extra 
effort from the programmer. Wouldn’t it make sense to somehow create the container so that 
it knows the types that it holds, eliminating the need for the downcast and a possible 
mistake? The solution is called a parameterized type mechanism. A parameterized type is a 
class that the compiler can automatically customize to work with particular types. For 
example, with a parameterized container, the compiler could customize that container so that 
it would accept only Shapes and fetch only Shapes.